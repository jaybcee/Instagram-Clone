// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Comment(params CommentWhereUniqueInput) *CommentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CommentWhereUniqueInput!", "Comment"},
		"comment",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExec{ret}
}

type CommentsParams struct {
	Where   *CommentWhereInput   `json:"where,omitempty"`
	OrderBy *CommentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Comments(params *CommentsParams) *CommentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
		"comments",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExecArray{ret}
}

type CommentsConnectionParams struct {
	Where   *CommentWhereInput   `json:"where,omitempty"`
	OrderBy *CommentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CommentConnection) Nodes() []Comment {
	var nodes []Comment
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CommentConnection) NodesPtr() []*Comment {
	var nodes []*Comment
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CommentsConnection(params *CommentsConnectionParams) *CommentConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
		"commentsConnection",
		[]string{"edges", "pageInfo"})

	return &CommentConnectionExec{ret}
}

func (client *Client) Post(params PostWhereUniqueInput) *PostExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PostWhereUniqueInput!", "Post"},
		"post",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExec{ret}
}

type PostsParams struct {
	Where   *PostWhereInput   `json:"where,omitempty"`
	OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Posts(params *PostsParams) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"posts",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExecArray{ret}
}

type PostsConnectionParams struct {
	Where   *PostWhereInput   `json:"where,omitempty"`
	OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PostConnection) Nodes() []Post {
	var nodes []Post
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PostConnection) NodesPtr() []*Post {
	var nodes []*Post
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PostsConnection(params *PostsConnectionParams) *PostConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"postsConnection",
		[]string{"edges", "pageInfo"})

	return &PostConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UserConnection) Nodes() []User {
	var nodes []User
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UserConnection) NodesPtr() []*User {
	var nodes []*User
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) CreateComment(params CommentCreateInput) *CommentExec {
	ret := client.Client.Create(
		params,
		[2]string{"CommentCreateInput!", "Comment"},
		"createComment",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExec{ret}
}

type CommentUpdateParams struct {
	Data  CommentUpdateInput      `json:"data"`
	Where CommentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateComment(params CommentUpdateParams) *CommentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CommentUpdateInput!", "CommentWhereUniqueInput!", "Comment"},
		"updateComment",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExec{ret}
}

type CommentUpdateManyParams struct {
	Data  CommentUpdateManyMutationInput `json:"data"`
	Where *CommentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyComments(params CommentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CommentUpdateManyMutationInput!", "CommentWhereInput"},
		"updateManyComments")
	return &BatchPayloadExec{exec}
}

type CommentUpsertParams struct {
	Where  CommentWhereUniqueInput `json:"where"`
	Create CommentCreateInput      `json:"create"`
	Update CommentUpdateInput      `json:"update"`
}

func (client *Client) UpsertComment(params CommentUpsertParams) *CommentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CommentWhereUniqueInput!", "CommentCreateInput!", "CommentUpdateInput!", "Comment"},
		"upsertComment",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExec{ret}
}

func (client *Client) DeleteComment(params CommentWhereUniqueInput) *CommentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CommentWhereUniqueInput!", "Comment"},
		"deleteComment",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExec{ret}
}

func (client *Client) DeleteManyComments(params *CommentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CommentWhereInput", "deleteManyComments")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePost(params PostCreateInput) *PostExec {
	ret := client.Client.Create(
		params,
		[2]string{"PostCreateInput!", "Post"},
		"createPost",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExec{ret}
}

type PostUpdateParams struct {
	Data  PostUpdateInput      `json:"data"`
	Where PostWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePost(params PostUpdateParams) *PostExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PostUpdateInput!", "PostWhereUniqueInput!", "Post"},
		"updatePost",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExec{ret}
}

type PostUpdateManyParams struct {
	Data  PostUpdateManyMutationInput `json:"data"`
	Where *PostWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPosts(params PostUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PostUpdateManyMutationInput!", "PostWhereInput"},
		"updateManyPosts")
	return &BatchPayloadExec{exec}
}

type PostUpsertParams struct {
	Where  PostWhereUniqueInput `json:"where"`
	Create PostCreateInput      `json:"create"`
	Update PostUpdateInput      `json:"update"`
}

func (client *Client) UpsertPost(params PostUpsertParams) *PostExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PostWhereUniqueInput!", "PostCreateInput!", "PostUpdateInput!", "Post"},
		"upsertPost",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExec{ret}
}

func (client *Client) DeletePost(params PostWhereUniqueInput) *PostExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PostWhereUniqueInput!", "Post"},
		"deletePost",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExec{ret}
}

func (client *Client) DeleteManyPosts(params *PostWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PostWhereInput", "deleteManyPosts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type PostOrderByInput string

const (
	PostOrderByInputIDAsc        PostOrderByInput = "id_ASC"
	PostOrderByInputIDDesc       PostOrderByInput = "id_DESC"
	PostOrderByInputFileNameAsc  PostOrderByInput = "fileName_ASC"
	PostOrderByInputFileNameDesc PostOrderByInput = "fileName_DESC"
	PostOrderByInputCaptionAsc   PostOrderByInput = "caption_ASC"
	PostOrderByInputCaptionDesc  PostOrderByInput = "caption_DESC"
	PostOrderByInputPostedAtAsc  PostOrderByInput = "postedAt_ASC"
	PostOrderByInputPostedAtDesc PostOrderByInput = "postedAt_DESC"
)

type CommentOrderByInput string

const (
	CommentOrderByInputIDAsc           CommentOrderByInput = "id_ASC"
	CommentOrderByInputIDDesc          CommentOrderByInput = "id_DESC"
	CommentOrderByInputUniqueNameAsc   CommentOrderByInput = "uniqueName_ASC"
	CommentOrderByInputUniqueNameDesc  CommentOrderByInput = "uniqueName_DESC"
	CommentOrderByInputCommentTextAsc  CommentOrderByInput = "commentText_ASC"
	CommentOrderByInputCommentTextDesc CommentOrderByInput = "commentText_DESC"
	CommentOrderByInputCommentedAtAsc  CommentOrderByInput = "commentedAt_ASC"
	CommentOrderByInputCommentedAtDesc CommentOrderByInput = "commentedAt_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc        UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc       UserOrderByInput = "id_DESC"
	UserOrderByInputNameAsc      UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc     UserOrderByInput = "name_DESC"
	UserOrderByInputEmailAsc     UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc    UserOrderByInput = "email_DESC"
	UserOrderByInputPasswordAsc  UserOrderByInput = "password_ASC"
	UserOrderByInputPasswordDesc UserOrderByInput = "password_DESC"
	UserOrderByInputPhoneAsc     UserOrderByInput = "phone_ASC"
	UserOrderByInputPhoneDesc    UserOrderByInput = "phone_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type PostUpdateWithoutOwnerDataInput struct {
	FileName *string                            `json:"fileName,omitempty"`
	Caption  *string                            `json:"caption,omitempty"`
	Comments *CommentUpdateManyWithoutPostInput `json:"comments,omitempty"`
}

type CommentWhereUniqueInput struct {
	ID         *string `json:"id,omitempty"`
	UniqueName *string `json:"uniqueName,omitempty"`
}

type CommentUpdateWithoutPostDataInput struct {
	UniqueName  *string                     `json:"uniqueName,omitempty"`
	CommentText *string                     `json:"commentText,omitempty"`
	User        *UserUpdateOneRequiredInput `json:"user,omitempty"`
}

type PostWhereInput struct {
	ID                    *string            `json:"id,omitempty"`
	IDNot                 *string            `json:"id_not,omitempty"`
	IDIn                  []string           `json:"id_in,omitempty"`
	IDNotIn               []string           `json:"id_not_in,omitempty"`
	IDLt                  *string            `json:"id_lt,omitempty"`
	IDLte                 *string            `json:"id_lte,omitempty"`
	IDGt                  *string            `json:"id_gt,omitempty"`
	IDGte                 *string            `json:"id_gte,omitempty"`
	IDContains            *string            `json:"id_contains,omitempty"`
	IDNotContains         *string            `json:"id_not_contains,omitempty"`
	IDStartsWith          *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string            `json:"id_not_ends_with,omitempty"`
	FileName              *string            `json:"fileName,omitempty"`
	FileNameNot           *string            `json:"fileName_not,omitempty"`
	FileNameIn            []string           `json:"fileName_in,omitempty"`
	FileNameNotIn         []string           `json:"fileName_not_in,omitempty"`
	FileNameLt            *string            `json:"fileName_lt,omitempty"`
	FileNameLte           *string            `json:"fileName_lte,omitempty"`
	FileNameGt            *string            `json:"fileName_gt,omitempty"`
	FileNameGte           *string            `json:"fileName_gte,omitempty"`
	FileNameContains      *string            `json:"fileName_contains,omitempty"`
	FileNameNotContains   *string            `json:"fileName_not_contains,omitempty"`
	FileNameStartsWith    *string            `json:"fileName_starts_with,omitempty"`
	FileNameNotStartsWith *string            `json:"fileName_not_starts_with,omitempty"`
	FileNameEndsWith      *string            `json:"fileName_ends_with,omitempty"`
	FileNameNotEndsWith   *string            `json:"fileName_not_ends_with,omitempty"`
	Caption               *string            `json:"caption,omitempty"`
	CaptionNot            *string            `json:"caption_not,omitempty"`
	CaptionIn             []string           `json:"caption_in,omitempty"`
	CaptionNotIn          []string           `json:"caption_not_in,omitempty"`
	CaptionLt             *string            `json:"caption_lt,omitempty"`
	CaptionLte            *string            `json:"caption_lte,omitempty"`
	CaptionGt             *string            `json:"caption_gt,omitempty"`
	CaptionGte            *string            `json:"caption_gte,omitempty"`
	CaptionContains       *string            `json:"caption_contains,omitempty"`
	CaptionNotContains    *string            `json:"caption_not_contains,omitempty"`
	CaptionStartsWith     *string            `json:"caption_starts_with,omitempty"`
	CaptionNotStartsWith  *string            `json:"caption_not_starts_with,omitempty"`
	CaptionEndsWith       *string            `json:"caption_ends_with,omitempty"`
	CaptionNotEndsWith    *string            `json:"caption_not_ends_with,omitempty"`
	PostedAt              *string            `json:"postedAt,omitempty"`
	PostedAtNot           *string            `json:"postedAt_not,omitempty"`
	PostedAtIn            []string           `json:"postedAt_in,omitempty"`
	PostedAtNotIn         []string           `json:"postedAt_not_in,omitempty"`
	PostedAtLt            *string            `json:"postedAt_lt,omitempty"`
	PostedAtLte           *string            `json:"postedAt_lte,omitempty"`
	PostedAtGt            *string            `json:"postedAt_gt,omitempty"`
	PostedAtGte           *string            `json:"postedAt_gte,omitempty"`
	Owner                 *UserWhereInput    `json:"owner,omitempty"`
	CommentsEvery         *CommentWhereInput `json:"comments_every,omitempty"`
	CommentsSome          *CommentWhereInput `json:"comments_some,omitempty"`
	CommentsNone          *CommentWhereInput `json:"comments_none,omitempty"`
	And                   []PostWhereInput   `json:"AND,omitempty"`
	Or                    []PostWhereInput   `json:"OR,omitempty"`
	Not                   []PostWhereInput   `json:"NOT,omitempty"`
}

type CommentUpsertWithWhereUniqueWithoutPostInput struct {
	Where  CommentWhereUniqueInput           `json:"where"`
	Update CommentUpdateWithoutPostDataInput `json:"update"`
	Create CommentCreateWithoutPostInput     `json:"create"`
}

type CommentWhereInput struct {
	ID                       *string             `json:"id,omitempty"`
	IDNot                    *string             `json:"id_not,omitempty"`
	IDIn                     []string            `json:"id_in,omitempty"`
	IDNotIn                  []string            `json:"id_not_in,omitempty"`
	IDLt                     *string             `json:"id_lt,omitempty"`
	IDLte                    *string             `json:"id_lte,omitempty"`
	IDGt                     *string             `json:"id_gt,omitempty"`
	IDGte                    *string             `json:"id_gte,omitempty"`
	IDContains               *string             `json:"id_contains,omitempty"`
	IDNotContains            *string             `json:"id_not_contains,omitempty"`
	IDStartsWith             *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string             `json:"id_not_ends_with,omitempty"`
	UniqueName               *string             `json:"uniqueName,omitempty"`
	UniqueNameNot            *string             `json:"uniqueName_not,omitempty"`
	UniqueNameIn             []string            `json:"uniqueName_in,omitempty"`
	UniqueNameNotIn          []string            `json:"uniqueName_not_in,omitempty"`
	UniqueNameLt             *string             `json:"uniqueName_lt,omitempty"`
	UniqueNameLte            *string             `json:"uniqueName_lte,omitempty"`
	UniqueNameGt             *string             `json:"uniqueName_gt,omitempty"`
	UniqueNameGte            *string             `json:"uniqueName_gte,omitempty"`
	UniqueNameContains       *string             `json:"uniqueName_contains,omitempty"`
	UniqueNameNotContains    *string             `json:"uniqueName_not_contains,omitempty"`
	UniqueNameStartsWith     *string             `json:"uniqueName_starts_with,omitempty"`
	UniqueNameNotStartsWith  *string             `json:"uniqueName_not_starts_with,omitempty"`
	UniqueNameEndsWith       *string             `json:"uniqueName_ends_with,omitempty"`
	UniqueNameNotEndsWith    *string             `json:"uniqueName_not_ends_with,omitempty"`
	CommentText              *string             `json:"commentText,omitempty"`
	CommentTextNot           *string             `json:"commentText_not,omitempty"`
	CommentTextIn            []string            `json:"commentText_in,omitempty"`
	CommentTextNotIn         []string            `json:"commentText_not_in,omitempty"`
	CommentTextLt            *string             `json:"commentText_lt,omitempty"`
	CommentTextLte           *string             `json:"commentText_lte,omitempty"`
	CommentTextGt            *string             `json:"commentText_gt,omitempty"`
	CommentTextGte           *string             `json:"commentText_gte,omitempty"`
	CommentTextContains      *string             `json:"commentText_contains,omitempty"`
	CommentTextNotContains   *string             `json:"commentText_not_contains,omitempty"`
	CommentTextStartsWith    *string             `json:"commentText_starts_with,omitempty"`
	CommentTextNotStartsWith *string             `json:"commentText_not_starts_with,omitempty"`
	CommentTextEndsWith      *string             `json:"commentText_ends_with,omitempty"`
	CommentTextNotEndsWith   *string             `json:"commentText_not_ends_with,omitempty"`
	CommentedAt              *string             `json:"commentedAt,omitempty"`
	CommentedAtNot           *string             `json:"commentedAt_not,omitempty"`
	CommentedAtIn            []string            `json:"commentedAt_in,omitempty"`
	CommentedAtNotIn         []string            `json:"commentedAt_not_in,omitempty"`
	CommentedAtLt            *string             `json:"commentedAt_lt,omitempty"`
	CommentedAtLte           *string             `json:"commentedAt_lte,omitempty"`
	CommentedAtGt            *string             `json:"commentedAt_gt,omitempty"`
	CommentedAtGte           *string             `json:"commentedAt_gte,omitempty"`
	User                     *UserWhereInput     `json:"user,omitempty"`
	Post                     *PostWhereInput     `json:"Post,omitempty"`
	And                      []CommentWhereInput `json:"AND,omitempty"`
	Or                       []CommentWhereInput `json:"OR,omitempty"`
	Not                      []CommentWhereInput `json:"NOT,omitempty"`
}

type UserCreateOneWithoutPostsInput struct {
	Create  *UserCreateWithoutPostsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

type UserUpsertWithWhereUniqueWithoutFollowersInput struct {
	Where  UserWhereUniqueInput                `json:"where"`
	Update UserUpdateWithoutFollowersDataInput `json:"update"`
	Create UserCreateWithoutFollowersInput     `json:"create"`
}

type UserCreateWithoutPostsInput struct {
	ID        *string                              `json:"id,omitempty"`
	Name      string                               `json:"name"`
	Email     string                               `json:"email"`
	Password  string                               `json:"password"`
	Phone     string                               `json:"phone"`
	Followers *UserCreateManyWithoutFollowingInput `json:"followers,omitempty"`
	Following *UserCreateManyWithoutFollowersInput `json:"following,omitempty"`
}

type CommentScalarWhereInput struct {
	ID                       *string                   `json:"id,omitempty"`
	IDNot                    *string                   `json:"id_not,omitempty"`
	IDIn                     []string                  `json:"id_in,omitempty"`
	IDNotIn                  []string                  `json:"id_not_in,omitempty"`
	IDLt                     *string                   `json:"id_lt,omitempty"`
	IDLte                    *string                   `json:"id_lte,omitempty"`
	IDGt                     *string                   `json:"id_gt,omitempty"`
	IDGte                    *string                   `json:"id_gte,omitempty"`
	IDContains               *string                   `json:"id_contains,omitempty"`
	IDNotContains            *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                   `json:"id_not_ends_with,omitempty"`
	UniqueName               *string                   `json:"uniqueName,omitempty"`
	UniqueNameNot            *string                   `json:"uniqueName_not,omitempty"`
	UniqueNameIn             []string                  `json:"uniqueName_in,omitempty"`
	UniqueNameNotIn          []string                  `json:"uniqueName_not_in,omitempty"`
	UniqueNameLt             *string                   `json:"uniqueName_lt,omitempty"`
	UniqueNameLte            *string                   `json:"uniqueName_lte,omitempty"`
	UniqueNameGt             *string                   `json:"uniqueName_gt,omitempty"`
	UniqueNameGte            *string                   `json:"uniqueName_gte,omitempty"`
	UniqueNameContains       *string                   `json:"uniqueName_contains,omitempty"`
	UniqueNameNotContains    *string                   `json:"uniqueName_not_contains,omitempty"`
	UniqueNameStartsWith     *string                   `json:"uniqueName_starts_with,omitempty"`
	UniqueNameNotStartsWith  *string                   `json:"uniqueName_not_starts_with,omitempty"`
	UniqueNameEndsWith       *string                   `json:"uniqueName_ends_with,omitempty"`
	UniqueNameNotEndsWith    *string                   `json:"uniqueName_not_ends_with,omitempty"`
	CommentText              *string                   `json:"commentText,omitempty"`
	CommentTextNot           *string                   `json:"commentText_not,omitempty"`
	CommentTextIn            []string                  `json:"commentText_in,omitempty"`
	CommentTextNotIn         []string                  `json:"commentText_not_in,omitempty"`
	CommentTextLt            *string                   `json:"commentText_lt,omitempty"`
	CommentTextLte           *string                   `json:"commentText_lte,omitempty"`
	CommentTextGt            *string                   `json:"commentText_gt,omitempty"`
	CommentTextGte           *string                   `json:"commentText_gte,omitempty"`
	CommentTextContains      *string                   `json:"commentText_contains,omitempty"`
	CommentTextNotContains   *string                   `json:"commentText_not_contains,omitempty"`
	CommentTextStartsWith    *string                   `json:"commentText_starts_with,omitempty"`
	CommentTextNotStartsWith *string                   `json:"commentText_not_starts_with,omitempty"`
	CommentTextEndsWith      *string                   `json:"commentText_ends_with,omitempty"`
	CommentTextNotEndsWith   *string                   `json:"commentText_not_ends_with,omitempty"`
	CommentedAt              *string                   `json:"commentedAt,omitempty"`
	CommentedAtNot           *string                   `json:"commentedAt_not,omitempty"`
	CommentedAtIn            []string                  `json:"commentedAt_in,omitempty"`
	CommentedAtNotIn         []string                  `json:"commentedAt_not_in,omitempty"`
	CommentedAtLt            *string                   `json:"commentedAt_lt,omitempty"`
	CommentedAtLte           *string                   `json:"commentedAt_lte,omitempty"`
	CommentedAtGt            *string                   `json:"commentedAt_gt,omitempty"`
	CommentedAtGte           *string                   `json:"commentedAt_gte,omitempty"`
	And                      []CommentScalarWhereInput `json:"AND,omitempty"`
	Or                       []CommentScalarWhereInput `json:"OR,omitempty"`
	Not                      []CommentScalarWhereInput `json:"NOT,omitempty"`
}

type CommentUpdateInput struct {
	UniqueName  *string                                    `json:"uniqueName,omitempty"`
	CommentText *string                                    `json:"commentText,omitempty"`
	User        *UserUpdateOneRequiredInput                `json:"user,omitempty"`
	Post        *PostUpdateOneRequiredWithoutCommentsInput `json:"Post,omitempty"`
}

type PostSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *PostWhereInput              `json:"node,omitempty"`
	And                        []PostSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PostSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PostSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserUpdateOneRequiredInput struct {
	Create  *UserCreateInput       `json:"create,omitempty"`
	Update  *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Name     *string `json:"name,omitempty"`
	Email    *string `json:"email,omitempty"`
	Password *string `json:"password,omitempty"`
	Phone    *string `json:"phone,omitempty"`
}

type UserUpdateDataInput struct {
	Name      *string                              `json:"name,omitempty"`
	Email     *string                              `json:"email,omitempty"`
	Password  *string                              `json:"password,omitempty"`
	Phone     *string                              `json:"phone,omitempty"`
	Posts     *PostUpdateManyWithoutOwnerInput     `json:"posts,omitempty"`
	Followers *UserUpdateManyWithoutFollowingInput `json:"followers,omitempty"`
	Following *UserUpdateManyWithoutFollowersInput `json:"following,omitempty"`
}

type PostUpdateManyMutationInput struct {
	FileName *string `json:"fileName,omitempty"`
	Caption  *string `json:"caption,omitempty"`
}

type PostUpdateManyWithoutOwnerInput struct {
	Create     []PostCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []PostWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []PostWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []PostWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []PostWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []PostUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []PostUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []PostScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []PostUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type PostWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PostUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where PostWhereUniqueInput            `json:"where"`
	Data  PostUpdateWithoutOwnerDataInput `json:"data"`
}

type CommentUpdateManyMutationInput struct {
	UniqueName  *string `json:"uniqueName,omitempty"`
	CommentText *string `json:"commentText,omitempty"`
}

type PostUpdateWithoutCommentsDataInput struct {
	FileName *string                                 `json:"fileName,omitempty"`
	Caption  *string                                 `json:"caption,omitempty"`
	Owner    *UserUpdateOneRequiredWithoutPostsInput `json:"owner,omitempty"`
}

type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Email *string `json:"email,omitempty"`
}

type CommentUpdateManyWithoutPostInput struct {
	Create     []CommentCreateWithoutPostInput                `json:"create,omitempty"`
	Delete     []CommentWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []CommentWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []CommentWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []CommentWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []CommentUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
	Upsert     []CommentUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
	DeleteMany []CommentScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []CommentUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type UserUpdateWithoutPostsDataInput struct {
	Name      *string                              `json:"name,omitempty"`
	Email     *string                              `json:"email,omitempty"`
	Password  *string                              `json:"password,omitempty"`
	Phone     *string                              `json:"phone,omitempty"`
	Followers *UserUpdateManyWithoutFollowingInput `json:"followers,omitempty"`
	Following *UserUpdateManyWithoutFollowersInput `json:"following,omitempty"`
}

type CommentUpdateWithWhereUniqueWithoutPostInput struct {
	Where CommentWhereUniqueInput           `json:"where"`
	Data  CommentUpdateWithoutPostDataInput `json:"data"`
}

type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

type UserWhereInput struct {
	ID                    *string          `json:"id,omitempty"`
	IDNot                 *string          `json:"id_not,omitempty"`
	IDIn                  []string         `json:"id_in,omitempty"`
	IDNotIn               []string         `json:"id_not_in,omitempty"`
	IDLt                  *string          `json:"id_lt,omitempty"`
	IDLte                 *string          `json:"id_lte,omitempty"`
	IDGt                  *string          `json:"id_gt,omitempty"`
	IDGte                 *string          `json:"id_gte,omitempty"`
	IDContains            *string          `json:"id_contains,omitempty"`
	IDNotContains         *string          `json:"id_not_contains,omitempty"`
	IDStartsWith          *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string          `json:"id_not_ends_with,omitempty"`
	Name                  *string          `json:"name,omitempty"`
	NameNot               *string          `json:"name_not,omitempty"`
	NameIn                []string         `json:"name_in,omitempty"`
	NameNotIn             []string         `json:"name_not_in,omitempty"`
	NameLt                *string          `json:"name_lt,omitempty"`
	NameLte               *string          `json:"name_lte,omitempty"`
	NameGt                *string          `json:"name_gt,omitempty"`
	NameGte               *string          `json:"name_gte,omitempty"`
	NameContains          *string          `json:"name_contains,omitempty"`
	NameNotContains       *string          `json:"name_not_contains,omitempty"`
	NameStartsWith        *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string          `json:"name_not_ends_with,omitempty"`
	Email                 *string          `json:"email,omitempty"`
	EmailNot              *string          `json:"email_not,omitempty"`
	EmailIn               []string         `json:"email_in,omitempty"`
	EmailNotIn            []string         `json:"email_not_in,omitempty"`
	EmailLt               *string          `json:"email_lt,omitempty"`
	EmailLte              *string          `json:"email_lte,omitempty"`
	EmailGt               *string          `json:"email_gt,omitempty"`
	EmailGte              *string          `json:"email_gte,omitempty"`
	EmailContains         *string          `json:"email_contains,omitempty"`
	EmailNotContains      *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string          `json:"email_not_ends_with,omitempty"`
	Password              *string          `json:"password,omitempty"`
	PasswordNot           *string          `json:"password_not,omitempty"`
	PasswordIn            []string         `json:"password_in,omitempty"`
	PasswordNotIn         []string         `json:"password_not_in,omitempty"`
	PasswordLt            *string          `json:"password_lt,omitempty"`
	PasswordLte           *string          `json:"password_lte,omitempty"`
	PasswordGt            *string          `json:"password_gt,omitempty"`
	PasswordGte           *string          `json:"password_gte,omitempty"`
	PasswordContains      *string          `json:"password_contains,omitempty"`
	PasswordNotContains   *string          `json:"password_not_contains,omitempty"`
	PasswordStartsWith    *string          `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith *string          `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith      *string          `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith   *string          `json:"password_not_ends_with,omitempty"`
	Phone                 *string          `json:"phone,omitempty"`
	PhoneNot              *string          `json:"phone_not,omitempty"`
	PhoneIn               []string         `json:"phone_in,omitempty"`
	PhoneNotIn            []string         `json:"phone_not_in,omitempty"`
	PhoneLt               *string          `json:"phone_lt,omitempty"`
	PhoneLte              *string          `json:"phone_lte,omitempty"`
	PhoneGt               *string          `json:"phone_gt,omitempty"`
	PhoneGte              *string          `json:"phone_gte,omitempty"`
	PhoneContains         *string          `json:"phone_contains,omitempty"`
	PhoneNotContains      *string          `json:"phone_not_contains,omitempty"`
	PhoneStartsWith       *string          `json:"phone_starts_with,omitempty"`
	PhoneNotStartsWith    *string          `json:"phone_not_starts_with,omitempty"`
	PhoneEndsWith         *string          `json:"phone_ends_with,omitempty"`
	PhoneNotEndsWith      *string          `json:"phone_not_ends_with,omitempty"`
	PostsEvery            *PostWhereInput  `json:"posts_every,omitempty"`
	PostsSome             *PostWhereInput  `json:"posts_some,omitempty"`
	PostsNone             *PostWhereInput  `json:"posts_none,omitempty"`
	FollowersEvery        *UserWhereInput  `json:"followers_every,omitempty"`
	FollowersSome         *UserWhereInput  `json:"followers_some,omitempty"`
	FollowersNone         *UserWhereInput  `json:"followers_none,omitempty"`
	FollowingEvery        *UserWhereInput  `json:"following_every,omitempty"`
	FollowingSome         *UserWhereInput  `json:"following_some,omitempty"`
	FollowingNone         *UserWhereInput  `json:"following_none,omitempty"`
	And                   []UserWhereInput `json:"AND,omitempty"`
	Or                    []UserWhereInput `json:"OR,omitempty"`
	Not                   []UserWhereInput `json:"NOT,omitempty"`
}

type PostCreateManyWithoutOwnerInput struct {
	Create  []PostCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []PostWhereUniqueInput        `json:"connect,omitempty"`
}

type PostUpdateOneRequiredWithoutCommentsInput struct {
	Create  *PostCreateWithoutCommentsInput     `json:"create,omitempty"`
	Update  *PostUpdateWithoutCommentsDataInput `json:"update,omitempty"`
	Upsert  *PostUpsertWithoutCommentsInput     `json:"upsert,omitempty"`
	Connect *PostWhereUniqueInput               `json:"connect,omitempty"`
}

type CommentCreateManyWithoutPostInput struct {
	Create  []CommentCreateWithoutPostInput `json:"create,omitempty"`
	Connect []CommentWhereUniqueInput       `json:"connect,omitempty"`
}

type UserUpsertNestedInput struct {
	Update UserUpdateDataInput `json:"update"`
	Create UserCreateInput     `json:"create"`
}

type UserCreateManyWithoutFollowingInput struct {
	Create  []UserCreateWithoutFollowingInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput            `json:"connect,omitempty"`
}

type CommentUpdateManyWithWhereNestedInput struct {
	Where CommentScalarWhereInput    `json:"where"`
	Data  CommentUpdateManyDataInput `json:"data"`
}

type UserCreateManyWithoutFollowersInput struct {
	Create  []UserCreateWithoutFollowersInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput            `json:"connect,omitempty"`
}

type CommentUpdateManyDataInput struct {
	UniqueName  *string `json:"uniqueName,omitempty"`
	CommentText *string `json:"commentText,omitempty"`
}

type PostCreateOneWithoutCommentsInput struct {
	Create  *PostCreateWithoutCommentsInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput           `json:"connect,omitempty"`
}

type PostUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  PostWhereUniqueInput            `json:"where"`
	Update PostUpdateWithoutOwnerDataInput `json:"update"`
	Create PostCreateWithoutOwnerInput     `json:"create"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PostScalarWhereInput struct {
	ID                    *string                `json:"id,omitempty"`
	IDNot                 *string                `json:"id_not,omitempty"`
	IDIn                  []string               `json:"id_in,omitempty"`
	IDNotIn               []string               `json:"id_not_in,omitempty"`
	IDLt                  *string                `json:"id_lt,omitempty"`
	IDLte                 *string                `json:"id_lte,omitempty"`
	IDGt                  *string                `json:"id_gt,omitempty"`
	IDGte                 *string                `json:"id_gte,omitempty"`
	IDContains            *string                `json:"id_contains,omitempty"`
	IDNotContains         *string                `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                `json:"id_not_ends_with,omitempty"`
	FileName              *string                `json:"fileName,omitempty"`
	FileNameNot           *string                `json:"fileName_not,omitempty"`
	FileNameIn            []string               `json:"fileName_in,omitempty"`
	FileNameNotIn         []string               `json:"fileName_not_in,omitempty"`
	FileNameLt            *string                `json:"fileName_lt,omitempty"`
	FileNameLte           *string                `json:"fileName_lte,omitempty"`
	FileNameGt            *string                `json:"fileName_gt,omitempty"`
	FileNameGte           *string                `json:"fileName_gte,omitempty"`
	FileNameContains      *string                `json:"fileName_contains,omitempty"`
	FileNameNotContains   *string                `json:"fileName_not_contains,omitempty"`
	FileNameStartsWith    *string                `json:"fileName_starts_with,omitempty"`
	FileNameNotStartsWith *string                `json:"fileName_not_starts_with,omitempty"`
	FileNameEndsWith      *string                `json:"fileName_ends_with,omitempty"`
	FileNameNotEndsWith   *string                `json:"fileName_not_ends_with,omitempty"`
	Caption               *string                `json:"caption,omitempty"`
	CaptionNot            *string                `json:"caption_not,omitempty"`
	CaptionIn             []string               `json:"caption_in,omitempty"`
	CaptionNotIn          []string               `json:"caption_not_in,omitempty"`
	CaptionLt             *string                `json:"caption_lt,omitempty"`
	CaptionLte            *string                `json:"caption_lte,omitempty"`
	CaptionGt             *string                `json:"caption_gt,omitempty"`
	CaptionGte            *string                `json:"caption_gte,omitempty"`
	CaptionContains       *string                `json:"caption_contains,omitempty"`
	CaptionNotContains    *string                `json:"caption_not_contains,omitempty"`
	CaptionStartsWith     *string                `json:"caption_starts_with,omitempty"`
	CaptionNotStartsWith  *string                `json:"caption_not_starts_with,omitempty"`
	CaptionEndsWith       *string                `json:"caption_ends_with,omitempty"`
	CaptionNotEndsWith    *string                `json:"caption_not_ends_with,omitempty"`
	PostedAt              *string                `json:"postedAt,omitempty"`
	PostedAtNot           *string                `json:"postedAt_not,omitempty"`
	PostedAtIn            []string               `json:"postedAt_in,omitempty"`
	PostedAtNotIn         []string               `json:"postedAt_not_in,omitempty"`
	PostedAtLt            *string                `json:"postedAt_lt,omitempty"`
	PostedAtLte           *string                `json:"postedAt_lte,omitempty"`
	PostedAtGt            *string                `json:"postedAt_gt,omitempty"`
	PostedAtGte           *string                `json:"postedAt_gte,omitempty"`
	And                   []PostScalarWhereInput `json:"AND,omitempty"`
	Or                    []PostScalarWhereInput `json:"OR,omitempty"`
	Not                   []PostScalarWhereInput `json:"NOT,omitempty"`
}

type UserUpdateInput struct {
	Name      *string                              `json:"name,omitempty"`
	Email     *string                              `json:"email,omitempty"`
	Password  *string                              `json:"password,omitempty"`
	Phone     *string                              `json:"phone,omitempty"`
	Posts     *PostUpdateManyWithoutOwnerInput     `json:"posts,omitempty"`
	Followers *UserUpdateManyWithoutFollowingInput `json:"followers,omitempty"`
	Following *UserUpdateManyWithoutFollowersInput `json:"following,omitempty"`
}

type PostUpdateManyWithWhereNestedInput struct {
	Where PostScalarWhereInput    `json:"where"`
	Data  PostUpdateManyDataInput `json:"data"`
}

type PostCreateInput struct {
	ID       *string                            `json:"id,omitempty"`
	FileName string                             `json:"fileName"`
	Caption  string                             `json:"caption"`
	Owner    UserCreateOneWithoutPostsInput     `json:"owner"`
	Comments *CommentCreateManyWithoutPostInput `json:"comments,omitempty"`
}

type PostUpdateManyDataInput struct {
	FileName *string `json:"fileName,omitempty"`
	Caption  *string `json:"caption,omitempty"`
}

type UserUpsertWithoutPostsInput struct {
	Update UserUpdateWithoutPostsDataInput `json:"update"`
	Create UserCreateWithoutPostsInput     `json:"create"`
}

type UserUpdateManyWithoutFollowingInput struct {
	Create     []UserCreateWithoutFollowingInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutFollowingInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutFollowingInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type CommentCreateInput struct {
	ID          *string                           `json:"id,omitempty"`
	UniqueName  string                            `json:"uniqueName"`
	CommentText string                            `json:"commentText"`
	User        UserCreateOneInput                `json:"user"`
	Post        PostCreateOneWithoutCommentsInput `json:"Post"`
}

type UserUpdateWithWhereUniqueWithoutFollowingInput struct {
	Where UserWhereUniqueInput                `json:"where"`
	Data  UserUpdateWithoutFollowingDataInput `json:"data"`
}

type PostCreateWithoutOwnerInput struct {
	ID       *string                            `json:"id,omitempty"`
	FileName string                             `json:"fileName"`
	Caption  string                             `json:"caption"`
	Comments *CommentCreateManyWithoutPostInput `json:"comments,omitempty"`
}

type UserUpdateWithoutFollowingDataInput struct {
	Name      *string                              `json:"name,omitempty"`
	Email     *string                              `json:"email,omitempty"`
	Password  *string                              `json:"password,omitempty"`
	Phone     *string                              `json:"phone,omitempty"`
	Posts     *PostUpdateManyWithoutOwnerInput     `json:"posts,omitempty"`
	Followers *UserUpdateManyWithoutFollowingInput `json:"followers,omitempty"`
}

type UserCreateWithoutFollowingInput struct {
	ID        *string                              `json:"id,omitempty"`
	Name      string                               `json:"name"`
	Email     string                               `json:"email"`
	Password  string                               `json:"password"`
	Phone     string                               `json:"phone"`
	Posts     *PostCreateManyWithoutOwnerInput     `json:"posts,omitempty"`
	Followers *UserCreateManyWithoutFollowingInput `json:"followers,omitempty"`
}

type UserUpsertWithWhereUniqueWithoutFollowingInput struct {
	Where  UserWhereUniqueInput                `json:"where"`
	Update UserUpdateWithoutFollowingDataInput `json:"update"`
	Create UserCreateWithoutFollowingInput     `json:"create"`
}

type PostCreateWithoutCommentsInput struct {
	ID       *string                        `json:"id,omitempty"`
	FileName string                         `json:"fileName"`
	Caption  string                         `json:"caption"`
	Owner    UserCreateOneWithoutPostsInput `json:"owner"`
}

type UserScalarWhereInput struct {
	ID                    *string                `json:"id,omitempty"`
	IDNot                 *string                `json:"id_not,omitempty"`
	IDIn                  []string               `json:"id_in,omitempty"`
	IDNotIn               []string               `json:"id_not_in,omitempty"`
	IDLt                  *string                `json:"id_lt,omitempty"`
	IDLte                 *string                `json:"id_lte,omitempty"`
	IDGt                  *string                `json:"id_gt,omitempty"`
	IDGte                 *string                `json:"id_gte,omitempty"`
	IDContains            *string                `json:"id_contains,omitempty"`
	IDNotContains         *string                `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                `json:"id_not_ends_with,omitempty"`
	Name                  *string                `json:"name,omitempty"`
	NameNot               *string                `json:"name_not,omitempty"`
	NameIn                []string               `json:"name_in,omitempty"`
	NameNotIn             []string               `json:"name_not_in,omitempty"`
	NameLt                *string                `json:"name_lt,omitempty"`
	NameLte               *string                `json:"name_lte,omitempty"`
	NameGt                *string                `json:"name_gt,omitempty"`
	NameGte               *string                `json:"name_gte,omitempty"`
	NameContains          *string                `json:"name_contains,omitempty"`
	NameNotContains       *string                `json:"name_not_contains,omitempty"`
	NameStartsWith        *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string                `json:"name_not_ends_with,omitempty"`
	Email                 *string                `json:"email,omitempty"`
	EmailNot              *string                `json:"email_not,omitempty"`
	EmailIn               []string               `json:"email_in,omitempty"`
	EmailNotIn            []string               `json:"email_not_in,omitempty"`
	EmailLt               *string                `json:"email_lt,omitempty"`
	EmailLte              *string                `json:"email_lte,omitempty"`
	EmailGt               *string                `json:"email_gt,omitempty"`
	EmailGte              *string                `json:"email_gte,omitempty"`
	EmailContains         *string                `json:"email_contains,omitempty"`
	EmailNotContains      *string                `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string                `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string                `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string                `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string                `json:"email_not_ends_with,omitempty"`
	Password              *string                `json:"password,omitempty"`
	PasswordNot           *string                `json:"password_not,omitempty"`
	PasswordIn            []string               `json:"password_in,omitempty"`
	PasswordNotIn         []string               `json:"password_not_in,omitempty"`
	PasswordLt            *string                `json:"password_lt,omitempty"`
	PasswordLte           *string                `json:"password_lte,omitempty"`
	PasswordGt            *string                `json:"password_gt,omitempty"`
	PasswordGte           *string                `json:"password_gte,omitempty"`
	PasswordContains      *string                `json:"password_contains,omitempty"`
	PasswordNotContains   *string                `json:"password_not_contains,omitempty"`
	PasswordStartsWith    *string                `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith *string                `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith      *string                `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith   *string                `json:"password_not_ends_with,omitempty"`
	Phone                 *string                `json:"phone,omitempty"`
	PhoneNot              *string                `json:"phone_not,omitempty"`
	PhoneIn               []string               `json:"phone_in,omitempty"`
	PhoneNotIn            []string               `json:"phone_not_in,omitempty"`
	PhoneLt               *string                `json:"phone_lt,omitempty"`
	PhoneLte              *string                `json:"phone_lte,omitempty"`
	PhoneGt               *string                `json:"phone_gt,omitempty"`
	PhoneGte              *string                `json:"phone_gte,omitempty"`
	PhoneContains         *string                `json:"phone_contains,omitempty"`
	PhoneNotContains      *string                `json:"phone_not_contains,omitempty"`
	PhoneStartsWith       *string                `json:"phone_starts_with,omitempty"`
	PhoneNotStartsWith    *string                `json:"phone_not_starts_with,omitempty"`
	PhoneEndsWith         *string                `json:"phone_ends_with,omitempty"`
	PhoneNotEndsWith      *string                `json:"phone_not_ends_with,omitempty"`
	And                   []UserScalarWhereInput `json:"AND,omitempty"`
	Or                    []UserScalarWhereInput `json:"OR,omitempty"`
	Not                   []UserScalarWhereInput `json:"NOT,omitempty"`
}

type PostUpdateInput struct {
	FileName *string                                 `json:"fileName,omitempty"`
	Caption  *string                                 `json:"caption,omitempty"`
	Owner    *UserUpdateOneRequiredWithoutPostsInput `json:"owner,omitempty"`
	Comments *CommentUpdateManyWithoutPostInput      `json:"comments,omitempty"`
}

type UserUpdateManyWithWhereNestedInput struct {
	Where UserScalarWhereInput    `json:"where"`
	Data  UserUpdateManyDataInput `json:"data"`
}

type UserUpdateOneRequiredWithoutPostsInput struct {
	Create  *UserCreateWithoutPostsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutPostsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput            `json:"connect,omitempty"`
}

type UserUpdateWithoutFollowersDataInput struct {
	Name      *string                              `json:"name,omitempty"`
	Email     *string                              `json:"email,omitempty"`
	Password  *string                              `json:"password,omitempty"`
	Phone     *string                              `json:"phone,omitempty"`
	Posts     *PostUpdateManyWithoutOwnerInput     `json:"posts,omitempty"`
	Following *UserUpdateManyWithoutFollowersInput `json:"following,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutFollowersInput struct {
	Where UserWhereUniqueInput                `json:"where"`
	Data  UserUpdateWithoutFollowersDataInput `json:"data"`
}

type UserUpdateManyWithoutFollowersInput struct {
	Create     []UserCreateWithoutFollowersInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutFollowersInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutFollowersInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type UserUpdateManyDataInput struct {
	Name     *string `json:"name,omitempty"`
	Email    *string `json:"email,omitempty"`
	Password *string `json:"password,omitempty"`
	Phone    *string `json:"phone,omitempty"`
}

type UserCreateInput struct {
	ID        *string                              `json:"id,omitempty"`
	Name      string                               `json:"name"`
	Email     string                               `json:"email"`
	Password  string                               `json:"password"`
	Phone     string                               `json:"phone"`
	Posts     *PostCreateManyWithoutOwnerInput     `json:"posts,omitempty"`
	Followers *UserCreateManyWithoutFollowingInput `json:"followers,omitempty"`
	Following *UserCreateManyWithoutFollowersInput `json:"following,omitempty"`
}

type PostUpsertWithoutCommentsInput struct {
	Update PostUpdateWithoutCommentsDataInput `json:"update"`
	Create PostCreateWithoutCommentsInput     `json:"create"`
}

type CommentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *CommentWhereInput              `json:"node,omitempty"`
	And                        []CommentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CommentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CommentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserCreateWithoutFollowersInput struct {
	ID        *string                              `json:"id,omitempty"`
	Name      string                               `json:"name"`
	Email     string                               `json:"email"`
	Password  string                               `json:"password"`
	Phone     string                               `json:"phone"`
	Posts     *PostCreateManyWithoutOwnerInput     `json:"posts,omitempty"`
	Following *UserCreateManyWithoutFollowersInput `json:"following,omitempty"`
}

type CommentCreateWithoutPostInput struct {
	ID          *string            `json:"id,omitempty"`
	UniqueName  string             `json:"uniqueName"`
	CommentText string             `json:"commentText"`
	User        UserCreateOneInput `json:"user"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserPreviousValuesFields = []string{"id", "name", "email", "password", "phone"}

type UserPreviousValues struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
	Phone    string `json:"phone"`
}

type CommentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CommentEdgeExec) Node() *CommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Comment"},
		"node",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExec{ret}
}

func (instance CommentEdgeExec) Exec(ctx context.Context) (*CommentEdge, error) {
	var v CommentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CommentEdgeExecArray) Exec(ctx context.Context) ([]CommentEdge, error) {
	var v []CommentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentEdgeFields = []string{"cursor"}

type CommentEdge struct {
	Node   Comment `json:"node"`
	Cursor string  `json:"cursor"`
}

type PostExec struct {
	exec *prisma.Exec
}

func (instance *PostExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

type CommentsParamsExec struct {
	Where   *CommentWhereInput
	OrderBy *CommentOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PostExec) Comments(params *CommentsParamsExec) *CommentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
		"comments",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExecArray{ret}
}

func (instance PostExec) Exec(ctx context.Context) (*Post, error) {
	var v Post
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostExecArray struct {
	exec *prisma.Exec
}

func (instance PostExecArray) Exec(ctx context.Context) ([]Post, error) {
	var v []Post
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostFields = []string{"id", "fileName", "caption", "postedAt"}

type Post struct {
	ID       string `json:"id"`
	FileName string `json:"fileName"`
	Caption  string `json:"caption"`
	PostedAt string `json:"postedAt"`
}

type UserExec struct {
	exec *prisma.Exec
}

type PostsParamsExec struct {
	Where   *PostWhereInput
	OrderBy *PostOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Posts(params *PostsParamsExec) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"posts",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExecArray{ret}
}

type FollowersParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Followers(params *FollowersParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"followers",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExecArray{ret}
}

type FollowingParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Following(params *FollowingParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"following",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExecArray{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserFields = []string{"id", "name", "email", "password", "phone"}

type User struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
	Phone    string `json:"phone"`
}

type PostSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PostSubscriptionPayloadExec) Node() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"node",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExec{ret}
}

func (instance *PostSubscriptionPayloadExec) PreviousValues() *PostPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostPreviousValues"},
		"previousValues",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostPreviousValuesExec{ret}
}

func (instance PostSubscriptionPayloadExec) Exec(ctx context.Context) (*PostSubscriptionPayload, error) {
	var v PostSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PostSubscriptionPayload, error) {
	var v []PostSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PostSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Post        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "User"},
		"node",
		UserFields)

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserConnectionFields = []string{}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type PostEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PostEdgeExec) Node() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"node",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExec{ret}
}

func (instance PostEdgeExec) Exec(ctx context.Context) (*PostEdge, error) {
	var v PostEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PostEdgeExecArray) Exec(ctx context.Context) ([]PostEdge, error) {
	var v []PostEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostEdgeFields = []string{"cursor"}

type PostEdge struct {
	Node   Post   `json:"node"`
	Cursor string `json:"cursor"`
}

type CommentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CommentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CommentConnectionExec) Edges() *CommentEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "CommentEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Comment"},
		"node",
		CommentFields)

	return &CommentEdgeExecArray{nodes}
}

func (instance *CommentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateComment"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CommentConnectionExec) Exec(ctx context.Context) (*CommentConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CommentConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CommentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CommentConnectionExecArray) Exec(ctx context.Context) ([]CommentConnection, error) {
	var v []CommentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentConnectionFields = []string{}

type CommentConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []CommentEdge `json:"edges"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CommentExec struct {
	exec *prisma.Exec
}

func (instance *CommentExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

func (instance *CommentExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"Post",
		[]string{"id", "fileName", "caption", "postedAt"})

	return &PostExec{ret}
}

func (instance CommentExec) Exec(ctx context.Context) (*Comment, error) {
	var v Comment
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentExecArray struct {
	exec *prisma.Exec
}

func (instance CommentExecArray) Exec(ctx context.Context) ([]Comment, error) {
	var v []Comment
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentFields = []string{"id", "uniqueName", "commentText", "commentedAt"}

type Comment struct {
	ID          string `json:"id"`
	UniqueName  string `json:"uniqueName"`
	CommentText string `json:"commentText"`
	CommentedAt string `json:"commentedAt"`
}

type CommentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CommentPreviousValuesExec) Exec(ctx context.Context) (*CommentPreviousValues, error) {
	var v CommentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CommentPreviousValuesExecArray) Exec(ctx context.Context) ([]CommentPreviousValues, error) {
	var v []CommentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentPreviousValuesFields = []string{"id", "uniqueName", "commentText", "commentedAt"}

type CommentPreviousValues struct {
	ID          string `json:"id"`
	UniqueName  string `json:"uniqueName"`
	CommentText string `json:"commentText"`
	CommentedAt string `json:"commentedAt"`
}

type CommentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CommentSubscriptionPayloadExec) Node() *CommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Comment"},
		"node",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentExec{ret}
}

func (instance *CommentSubscriptionPayloadExec) PreviousValues() *CommentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CommentPreviousValues"},
		"previousValues",
		[]string{"id", "uniqueName", "commentText", "commentedAt"})

	return &CommentPreviousValuesExec{ret}
}

func (instance CommentSubscriptionPayloadExec) Exec(ctx context.Context) (*CommentSubscriptionPayload, error) {
	var v CommentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CommentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CommentSubscriptionPayload, error) {
	var v []CommentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CommentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Comment     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PostPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PostPreviousValuesExec) Exec(ctx context.Context) (*PostPreviousValues, error) {
	var v PostPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PostPreviousValuesExecArray) Exec(ctx context.Context) ([]PostPreviousValues, error) {
	var v []PostPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostPreviousValuesFields = []string{"id", "fileName", "caption", "postedAt"}

type PostPreviousValues struct {
	ID       string `json:"id"`
	FileName string `json:"fileName"`
	Caption  string `json:"caption"`
	PostedAt string `json:"postedAt"`
}

type PostConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PostConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PostConnectionExec) Edges() *PostEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PostWhereInput", "PostOrderByInput", "PostEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Post"},
		"node",
		PostFields)

	return &PostEdgeExecArray{nodes}
}

func (instance *PostConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePost"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PostConnectionExec) Exec(ctx context.Context) (*PostConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PostConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PostConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PostConnectionExecArray) Exec(ctx context.Context) ([]PostConnection, error) {
	var v []PostConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostConnectionFields = []string{}

type PostConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []PostEdge `json:"edges"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name", "email", "password", "phone"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserEdgeFields = []string{"cursor"}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}
